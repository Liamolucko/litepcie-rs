use std::io;

use pci_driver::regions::{AsPciSubregion, BackedByPciSubregion, PciRegion};

use crate::{CsrKind, SocInfo};

/// A handle to a read-only CSR in the SoC.
pub struct CsrRo<'a, const N: usize = 1> {
    region: &'a dyn PciRegion,
    offset: u64,
}

impl<'a, const N: usize> CsrRo<'a, N> {
    pub fn read(&self) -> io::Result<[u32; N]> {
        let mut result = [0; N];
        for i in 0..N.try_into().unwrap() {
            result[i] = self
                .region
                .read_le_u32(self.offset + u64::try_from(4 * i).unwrap())?;
        }
        Ok(result)
    }
}

impl<'a, const N: usize> BackedByPciSubregion<'a> for CsrRo<'a, N> {
    fn backed_by(as_subregion: impl AsPciSubregion<'a>) -> Self {
        let subregion = as_subregion.as_subregion();
        Self {
            region: subregion.underlying_region(),
            offset: subregion.offset_in_underlying_region(),
        }
    }
}

/// A handle to a read-write CSR in the SoC.
pub struct CsrRw<'a, const N: usize = 1> {
    region: &'a dyn PciRegion,
    offset: u64,
}

impl<'a, const N: usize> CsrRw<'a, N> {
    pub fn read(&self) -> io::Result<[u32; N]> {
        let mut result = [0; N];
        for i in 0..N.try_into().unwrap() {
            result[i] = self
                .region
                .read_le_u32(self.offset + u64::try_from(4 * i).unwrap())?;
        }
        Ok(result)
    }

    pub fn write(&self, value: [u32; N]) -> io::Result<()> {
        for i in 0..N.try_into().unwrap() {
            self.region
                .write_le_u32(self.offset + u64::try_from(4 * i).unwrap(), value[i])?;
        }
        Ok(())
    }
}

impl<'a, const N: usize> BackedByPciSubregion<'a> for CsrRw<'a, N> {
    fn backed_by(as_subregion: impl AsPciSubregion<'a>) -> Self {
        let subregion = as_subregion.as_subregion();
        Self {
            region: subregion.underlying_region(),
            offset: subregion.offset_in_underlying_region(),
        }
    }
}

/// A trait for types that are collections of CSRs.
///
/// `CsrRo`, `CsrRw` and types generated by `csr_struct!` implement this.
pub trait CsrGroup<'a> {
    /// The list of CSR addresses this type needs to know before it can be
    /// constructed from a [`PciSubregion`](pci_driver::regions::PciSubregion).
    type Addrs;
    /// Figures out the addresses of all the CSRs in this group from an
    /// `soc_info` and the name of the module that contains them.
    fn addrs(soc_info: &SocInfo, module: &str) -> crate::Result<Self::Addrs>;
    /// Creates a handle to this group of CSRs from the [`PciSubregion`] that
    /// contains them.
    ///
    /// That [`PciSubregion`] should be BAR 0 of the PCI device you're
    /// communicating with.
    ///
    /// [`PciSubregion`]: (pci_driver::regions::PciSubregion)
    fn backed_by(as_subregion: impl AsPciSubregion<'a>, addrs: Self::Addrs) -> Self;
}

impl<'a, const N: usize> CsrGroup<'a> for CsrRo<'a, N> {
    type Addrs = u64;

    fn addrs(soc_info: &SocInfo, module: &str) -> crate::Result<Self::Addrs> {
        // We're down to the individual CSR now, which means there's nothing left to add
        // on to `module`: it's the final name of the CSR.
        let info = soc_info
            .csr_registers
            .get(module)
            .ok_or_else(|| crate::Error::MissingCsr {
                csr: module.to_owned(),
            })?;

        let expected_size = N.try_into().unwrap();
        if info.size != expected_size {
            return Err(crate::Error::CsrWrongSize {
                csr: module.to_owned(),
                expected: expected_size,
                found: info.size,
            });
        }
        if info.kind != CsrKind::ReadOnly {
            return Err(crate::Error::CsrWrongKind {
                csr: module.to_owned(),
                expected: CsrKind::ReadOnly,
                found: info.kind,
            });
        }

        Ok(info.addr)
    }

    fn backed_by(as_subregion: impl AsPciSubregion<'a>, addrs: Self::Addrs) -> Self {
        <Self as BackedByPciSubregion>::backed_by(
            as_subregion.subregion(addrs..addrs + 4 * u64::try_from(N).unwrap()),
        )
    }
}

impl<'a, const N: usize> CsrGroup<'a> for CsrRw<'a, N> {
    type Addrs = u64;

    fn addrs(soc_info: &SocInfo, module: &str) -> crate::Result<Self::Addrs> {
        // We're down to the individual CSR now, which means there's nothing left to add
        // on to `module`: it's the final name of the CSR.
        let info = soc_info
            .csr_registers
            .get(module)
            .ok_or_else(|| crate::Error::MissingCsr {
                csr: module.to_owned(),
            })?;

        let expected_size = N.try_into().unwrap();
        if info.size != expected_size {
            return Err(crate::Error::CsrWrongSize {
                csr: module.to_owned(),
                expected: expected_size,
                found: info.size,
            });
        }
        if info.kind != CsrKind::ReadWrite {
            return Err(crate::Error::CsrWrongKind {
                csr: module.to_owned(),
                expected: CsrKind::ReadWrite,
                found: info.kind,
            });
        }

        Ok(info.addr)
    }

    fn backed_by(as_subregion: impl AsPciSubregion<'a>, addrs: Self::Addrs) -> Self {
        <Self as BackedByPciSubregion>::backed_by(
            as_subregion.subregion(addrs..addrs + 4 * u64::try_from(N).unwrap()),
        )
    }
}

impl<'a, T: CsrGroup<'a>> CsrGroup<'a> for Option<T> {
    type Addrs = Option<T::Addrs>;

    fn addrs(soc_info: &SocInfo, module: &str) -> crate::Result<Option<T::Addrs>> {
        match T::addrs(soc_info, module) {
            Ok(addrs) => Ok(Some(addrs)),
            Err(crate::Error::MissingCsr { .. }) => Ok(None),
            Err(other) => Err(other),
        }
    }

    fn backed_by(as_subregion: impl AsPciSubregion<'a>, addrs: Option<T::Addrs>) -> Self {
        addrs.map(|addrs| T::backed_by(as_subregion, addrs))
    }
}

/// A macro similar to `pci_driver::pci_struct` for defining groups of LiteX
/// CSRs.
///
/// The main difference is that instead of hardcoding the offsets of all the
/// fields, it looks them up from an [`SocInfo`].
///
/// This means that it can't implement [`BackedByPciSubregion`] directly, since
/// there's no way to pass it an [`SocInfo`] through that trait. Instead it
/// implements [`CsrGroup`].
///
/// [`BackedByPciSubregion`]: (pci_driver::regions::BackedByPciSubregion)
#[macro_export]
macro_rules! csr_struct {
    (
        $(
            $(#[$attr:meta])*
            $vis:vis struct $name:ident<$lifetime:lifetime> {
                $(
                    $(#[$field_attr:meta])*
                    $field_name:ident: $field_ty:ty
                ),* $(,)?
            }
        )*
    ) => {
        $(
            $(#[$attr])*
            #[derive($crate::std::clone::Clone, $crate::std::marker::Copy)]
            $vis struct $name<$lifetime, T = $crate::pci_driver::regions::PciSubregion<$lifetime>> {
                region: T,
                $($field_name: <$field_ty as $crate::csr::CsrGroup<$lifetime>>::Addrs,)*
            }

            impl<$lifetime> $crate::csr::CsrGroup<$lifetime> for $name<$lifetime> {
                type Addrs = $name<$lifetime, ()>;
                fn addrs(soc_info: &$crate::SocInfo, module: &$crate::std::primitive::str) -> $crate::Result<Self::Addrs> {
                    Ok($name {
                        region: (),
                        $(
                            $field_name: <$field_ty as $crate::csr::CsrGroup>::addrs(
                                soc_info,
                                &$crate::std::format!("{}_{}", module, $crate::std::stringify!($field_name))
                            )?,
                        )*
                    })
                }
                fn backed_by(as_subregion: impl $crate::pci_driver::regions::AsPciSubregion<'a>, addrs: Self::Addrs) -> Self {
                    Self {
                        region: as_subregion.as_subregion(),
                        $($field_name: addrs.$field_name,)*
                    }
                }
            }

            impl<$lifetime> $name<$lifetime> {
                $(
                    $(#[$field_attr])*
                    $vis fn $field_name(&self) -> $field_ty {
                        <$field_ty as $crate::csr::CsrGroup<$lifetime>>::backed_by(&self.region, self.$field_name)
                    }
                )*
            }
        )*
    };
}
